<!-- CREATE TOPIC DIRECTORY, THE LANGUAGE, THE TITLE AT HEAD AND WRITE YOUR PAPER OR USE THE SCRIPT TO AUTOMATE PROCCESS! -->

<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../../assets/css/markdown.css">
    <link rel="shortcut icon" href="../../../assets/images/sterile-box.ico">
    <title>Void | Guides</title>

    <script type="module">
        import ZeroMd, { STYLES } from 'https://cdn.jsdelivr.net/npm/zero-md@3'
      
        customElements.define('zero-md', class extends ZeroMd {
          async load() {
            await super.load()
            this.template = STYLES.preset('dark')
          }
        })
    </script>
</head>
<body>

<header>
    <a href="../../papers.html">
        <p id="footer-text">0xDant &copy; 2023</p>
    </a>
</header>

<!-- ARTICLE BEGIN -->
<zero-md>
<script type="text/markdown">

# Java @ Masterclass

## Links

- Testes: `https://www.devmedia.com.br/junit-tutorial/1432`;
- Notations (docs): `http://docs.oracle.com/javase/tutorial/java/annotations/`;
- Casting de Objetos (docs): `http://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html`;
- Enum (docs): `https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html`;
- Method Hiding (forum): `http://stackoverflow.com/questions/16313649/`.

## Introducao

- Cada arquivo _.java_ pode conter apenas uma classe publica, e a mesma tem o nome igual ao do arquivo em que esta;
- Todo programa precisa ter um metodo _main_ como ponto de entrada, e deve ser estatico pois na implementacao do java nossa jvm nao instancia nossa classe, apenas faz um call na principal;

## Comentarios, Pacotes & Saida de Dados!

```java
// Classe `ArrayList` dentro do pacote `java.util`
import java.util.ArrayList;
// Todas as classes dentro do pacote `java.security`
import java.security.*;

// (oneline) Classe com o mesmo nome do arquivo
public class LearnJava
{
    /*
     * (javadocs) Metodo main, ponto de partida
    */
    public static void main(String[] args)
    {
        /*
            (multiline) Saida de dados
        */
        System.out.println("Hello, World!");

        // println = print + line feed
        System.out.println(
            "Int: " + 10 + ", " +
            "Double: " + 3.14 + ", " +
            "Boolean: " + true
        );

        // print = print - line feed
        System.out.print("Hello, ");
        System.out.print("World!");
        System.out.print("\n");
    }
}
```

## Tipos de Dados Primitivos

- Nao temos tipos sem sinal, os _unsigneds_.

```java
public class LearnJava
{
    public static void main(String[] args)
    {
        /*
            byte: inteiro assinado de 8 bits
            (-128 <= byte =< 127)
        */
        byte fooByte = 100;

        /*
            short: inteiro assinado de 16 bits
            (-32,768 <= short <= 32,767)
        */
        short fooShort = 10000;

        /*
            integer: inteiro assinado de 32 bits
            (-2,147,483,648 <= int <= 2,147,483,647)
        */
        int fooInt = 1;

        /*
            long: inteiro assinado de 64 bits
            (-9,223,372,036,854,775,808 <= long <= 9,223,372,036,854,775,807)

            'L' eh usado para indicar que a variavel eh do tipo `long`,
            sem ele tudo eh tratado por padrao como inteiro
        */
        long fooLong = 100000L;

        /*
            float: ponto flutuante de 32 bits, precisao simples padrao IEEE 754

            `f` eh usado para indicar que o valor da variavel eh do tipo float, sem isso ela sera tratada como double
        */
        float fooFloat = 234.5f;

        /*
            double: ponto flutuante de 64 bits, de precisao dupla padrao IEEE 754
        */
        double fooDouble = 123.4;

        /*
            boolean: true, false
        */
        boolean fooBoolean = true;
        boolean barBoolean = false;

        /*
            char: caractere unicode de 16 bits
        */
        char fooChar = 'A';

        /*
            final: cria um campo `readonly`, faz com que a variavel seja imutavel (constante)
        */
        final int FOO_BAR_BAZ = 1234;

        /*
            tipo nao primitivo!

            strings: cadeia de caracteres
        */
       String fooString = "Oh my god, it's Java!\nWow.";
       System.out.println(fooString);
    }
}
```

## Estruturas de Dados & Tipo de Dado ENUM

- ArrayLists, LinkedLists, Maps, Hashmaps, (entre outros);
- **Arrays**
    - Tamanho precisa ser declarado;
    - Sintaxe: `<data_type>[] <name> = new <data_type>[size]`

```java
public class LearnJava
{
    public static void main(String[] args)
    {
        // Sem ter os elementos declarados diretamente
        int[] intArray = new int[10];
        String[] stringArray = new String[1];
        boolean[] booleanArray = new boolean[100];

        // Sabendo os itens
        int[] fooArray = { 10, 100, 1000 };

        // Acessando o primeiro indice
        System.out.println("idx[0]: " + fooArray[0]);

        // Alterando o valor do segundo indice
        fooArray[1] = 1337;
        System.out.println("idx[1]: " + fooArray[1]);
    }
}
```

- **Enum**:
    - Tipo de dado especial que permite que uma variavel seja um conjunto de constantes predefinidas;
    - A variavel deve ser igual a um dos valores que foram previamente definidos por ela;
    - Por serem constantes, nomes devem ser em letra maiuscula;
    - Podem ser muito poderosos, podendo incluir metodos e outros campos.

```java
public enum Dia
{
    DOMINGO,
    SEGUNDA,
    TERCA,
    QUARTA,
    QUINTA,
    SEXTA,
    SABADO
}

public class EnumTeste
{
    // @var: enum
    Dia dia;

    // @constructor
    public EnumTeste(Dia dia)
    {
        this.dia = dia;
    }

    public void digaComoE()
    {
        switch (dia) {
            case SEGUNDA:
                System.out.println("Segundas são ruins");
                break;
            case SEXTA:
                System.out.println("Sextas são melhores");
                break;
            case SABADO: 
            case DOMINGO:
                System.out.println("Finais de semana são os melhores");
                break;
            default:
                System.out.println("Dias no meio da semana são mais ou menos");
                break;
        }
    }

    public static void main(String[] args)
    {
        EnumTeste primeiroDia = new EnumTeste(Dia.SEGUNDA);
        // => Segundas-feiras sao ruins
        primeiroDia.digaComoE();

        EnumTeste terceiroDia = new EnumTeste(Dia.QUARTA);
        // => Dias no meio da semana sao mais ou menos
        terceiroDia.digaComoE();
    }
}
```

## Casting & Conversao de Dados

- Outras classes:
    - Double, Long, String.
- Casting:
    - Podemos converter _objetos java_!

```java
// Exemplo (ha muitos outros!)

// Str to Int
Integer.parseInt("123");

// Int to Str
Integer.toString(123);
```

## Operadores

```java
public class LearnJava
{
    public static void main(String[] args)
    {
        // Forma abreviada de escrever multiplas declaracoes
        int foo = 1, bar = 2;

        /*
            @ operadores aritmeticos

            +, -, *, /, %

            @ operadores logicos

            ==, !=, >, <, <=, =>

            @ operadores bitwise / bit-a-bit

            ~, <<, >>, >>>, &, |, ^

            @ operadores de incremento / decremento

            ++, --
        */
    }
}
```

## Estruturas de Controle de Fluxo

- O _switch_ funciona com os seguintes tipos de dados:
    - byte (Byte)
    - short (Short)
    - char (Character)
    - int (Integer)
    - Outras classes especiais como:
        - enum
        - string

```java
public class LearnJava
{
    public static void main(String[] args)
    {
        // if's aninhados
        if (1 > 2) {
            System.out.println("1 > 2!");
        } else if (1 == 2) {
            System.out.println("1 == 2");
        } else {
            System.out.println("1 != 2");
        }

        // switch-case
        int month = 3;

        String monthString;

        switch (month) {
            case 1:
                monthString = "Jan.";
                break;
            case 2:
                monthString = "Feb.";
                break;
            case 3:
                monthString = "Mar.";
                break;
            default:
                monthString = "Idk.";
                break;
        }

        System.out.println("Out: " + monthString);

        // operadores ternarios
        int foo = 5;

        System.out.println((foo & 1) == 1 ? "Odd" : "Even");
    }
}
```

## Estruturas de Iteracao

```java
public class LearnJava
{
    public static void main(String[] args)
    {
        // while
        while (1) {
            System.out.println("you'll never forget me..."); 
        }

        // do / while
        do {
            System.out.println("you'll never forget me..."); 
        } while(1);

        // for
        for (;;) {
            System.out.println("you'll never forget me..."); 
        }

        // foreach
        int[] fooList = { 1, 2, 3, 4, 5 };

        for (int item: fooList) {
            System.out.println("Item: " + item); 
        }
    }
}
```

## Java @ POO

### Classes, Metodos Construtores, Getters e Setters (Encapsulamento)

- Metodos construtores levam o mesmo nome da classe.

```java
/*
    Sintaxe de declaracao de classe:

    <public/private/protected> class <nome da classe>
    {
        // attr.
        
        // constructor
        
        // methods
    }

    ###

    Sintaxe de declaracao de metodos
    
    <escopo> <tipo de retorno> <nome do método>(<args>)
    {
        // code
    }
*/

class Bicicleta
{
    // public: acessivel de qualquer lugar
    public int ritmo;
    // private: acessivel apenas a classe
    private int velocidade;
    // protected: acessivel a classe e suas subclasses
    protected int catraca;
    // default: acessivel apenas ao pacote
    String nome;

    // Construtor padrao
    public Bicicleta()
    {
        ritmo = 50;
        velocidade = 5;
        catraca = 1;
        nome = "Bontrager";
    }

    // Construtor especifico (com argumentos)
    public Bicicleta(
        int ritmoInicial,
        int velocidadeInicial,
        int catracaInicial,
        String nome
    ) {
        this.ritmo = ritmoInicial;
        this.velocidade = velocidadeInicial;
        this.catraca = catracaInicial;
        this.nome = nome;
    }

    // Getters, Setters
    public int getRitmo()
    {
        return ritmo;
    }

    public void setRitmo(int value)
    {
        this.ritmo = value;
    }

    public void setEquipamento(int value)
    {
        this.catraca = value;
    }

    public void aumentarVelocidade(int value)
    {
        this.velocidade += value;
    }

    public void diminuirVelocidade(int value)
    {
        this.velocidade -= value;
    }

    public void setNome(String value)
    {
        this.nome = value;
    }

    // Metodo para mostrar os valores dos atributos deste objeto
    // Aqui usamos uma notation, a @Override
    @Override
    public String toString()
    {
        return
            "catraca: "    + catraca    + " " +
            "ritmo: "      + ritmo      + " " +
            "velocidade: " + velocidade + " " +
            "nome: "       + nome;
    }
}

public class LearnJava
{
    public static void main(String[] args)
    {
        // Instanciando uma classe
        Bicicleta caloi = new Bicicleta();

        // Chamando seus metodos
        caloi.aumentarVelocidade(3);
        caloi.setRitmo(100);

        // Convencao para mostrar os valores do objeto
        System.out.println("Infos: " + caloi.toString());
    }
}
```

### Heranca

- Podemos estender somente uma classe.

```java
// Subclasse
class Velocipede extends Bicicleta
{
    // Construtor
    public Velodipede(int ritmoInicial, int velocidadeInicial)
    {
        // Chama o construtor do pai com os argumentos necessarios
        super(ritmoInicial, velocidadeInicial, 0, "PennyFarthing");
    }

    // Esse tipo de veiculo nao possui catraca, portanto sobreescrevemos o metodo
    @Override
    public void setEquipamento(int catraca)
    {
        catraca = 0;
    }
}
```

### Interfaces

- Podemos implementar mais de uma interface por classe.

```java
/*
    Sintaxe de declaracao de interface

    <nível de acesso> interface <nome-da-interface> extends <super-interfaces>
    {
        // Constantes
        // Declarações de método
    }

    public class ClasseExemplo extends ExemploClassePai implements InterfaceUm, InterfaceDois
    {
        @Override
        public void InterfaceUmMetodo() {}

        @Override
        public void InterfaceDoisMetodo() {}
    }
*/

public interface Comestivel
{
    // Metodo de implementacao obrigatorio para as subclasses
    public void comer();
}

public interface Digerivel
{
    /*
        Em Java8 interfaces podem ter metodos default, assim:

        public void digerir() { System.out.println("digerindo ..."); }
    */

    public void digerir();
}

// Criando uma classe que implementa ambas as interfaces
public class Fruta implements Comestivel, Digerivel
{
    @Override
    public void comer()
    {
        // code...
    }

    @Override
    public void digerir()
    {
        // code...
    }
}
```

### Classes Abstratas

- Marcar uma classe como abstrata significa que ela contem metodos abstratos, que devem ser definidos em uma classe filha;
- Semelhante as interfaces, classes abstratas nao pode ser instanciadas, ao inves disso devem ser estendidas e os metodos abstratos definidos;
- Diferente de interfaces, classes abstratas podem conter uma mistura de metodos concretos e abstratos, isso porque interfaces nao podem ter um corpo a menos que o metodo seja estatico e as variaveis sejam finais;
- Classes abstratas tambem podem ter o metodo "main";
- Nao ha necessidade de inicializar variaveis, no entanto, em uma interface, a variavel eh implicitamente do tipo _final_, e, portanto, tem de ser inicializada;
- O java nao permite a sobreescrita de metodos estaticos, portanto nao poderiamos dar um override na main. O que estamos fazendo eh chamado de **method hiding**.

```java
/*
    Sintaxe de declaracao de classe abstrata

    <Nível de acesso> abstract <nome-da-classe-abstrata> extends <estende super-abstratas-classes>
    {
        // Constantes e variaveis
        // Declaracoes de metodo
    }
*/
public abstract class Animal
{
    // Attrs.
    protected int idade;

    // Metodos abstratos
    public abstract void fazerSom();

    // Metodos concretos
    public void comer()
    {
        System.out.println("Eu sou um animal e estou comendo.");  

        // Nota: podemos acessar variaveis privadas aqui
        idade = 30;
    }

    public void mostrarIdade()
    {
        System.out.println(idade);
    }

    // Main
    public static void main(String[] args)
    {
        // Nao sera printado caso seja estendido de outra classe com main!
        System.out.println("Eu sou abstrata");
    }
}

class Cachorro extends Animal
{
    @Override
    public void fazerSom()
    {
        System.out.println("Bark");
    }

    // Aqui nao eh necessario usar a notation @Override!
    public static void main(String[] args)
    {
        Cachorro pluto = new Cachorro();

        pluto.fazerSom();
        pluto.comer();
        pluto.mostrarIdade();
    }
}
```

### Classes Finais

- Classes finais sao classes que nao poder ser herdadas e sao, portanto, um filho final;
- Metodos finais, assim como classes finais, nao podem ser substituidos por uma classe filha e sao, portanto, a implementacao final do metodo.

```java
/*
    Sintaxe de declaracao de classe final

    <nível de acesso> final <nome-da-classe-final>
    {
        // Constantes e variáveis
        // Declarações de metodo
    }

    ###

    Sintaxe de metodos finais:

    <modificador-de-acesso> final <tipo-de-retorno> <nome-do-metodo>(<argumentos>)
    {
        // code...
    }
*/

// Classe abstrata
public final class TigreDenteDeSabre extends Animal
{
    @Override
    public void fazerSom();
    {
        System.out.println("Roar!");
    }
}

// Classe com metodos finais
public abstract class Mamifero()
{
    public final boolean EhImpulsivo()
    {
        return true;
    }
}
```

### Polimorfismo

- Permite reutilizar e/ou dar acoes diferentes para elementos de uma classe, nela temos dois tipos:
    - _Estatico_ / Sobrecarga: a mesma operacao eh implementada varias vezes na mesma classe (**method overloading**);
        - Permite que metodos com o mesmo nome, mas diferentes assinaturas (quantidade ou tipos de parametros), coexistam na mesma classe;
        - A escolha de qual metodo sera chamado ocorre em _tempo de compilacao_.
    - _Dinamico_ / Sobreposicao: acontece na heranca, quando uma subclasse sobrepoe o metodo original;
        - O metodo eh sobreescrito (_override_) em uma classe derivada;
        - A escolha do metodo eh feita em _tempo de execucao_ baseada no tipo de objeto.

- **Estatico**:

```java
class Calc
{
    public int sum(int a, int b)
    {
        // Metodo para somar dois inteiros
    }

    public int sum(int a, int b, int c)
    {
        // Metodo para somar tres inteiros
    }

    public int sum(double a, double b)
    {
        // Metodo para somar dois numeros com ponto flutuante
    }
}

public class Main
{
    public static void main(String[] args)
    {
        Calc calc = new Calc();

        System.out.println("2 [int]: " + calc.sum(5, 10));
        System.out.println("3 [int]: " + calc.sum(5, 10, 15));
        System.out.println("2 [dbl]: " + calc.sum(5.5, 2.3));
    }
}
```

- **Dinamico**:

```java
class Animal
{
    // Metodo generico
    public void say()
    {
        System.out.println("Something...");
    }
}

class Dog extends Animal
{
    // Sobreescrevendo o metodo pai, say()
    @Override
    public void say()
    {
        System.out.println("dog says: woof woof!");
    }
}

class Cat extends Animal
{
    // Sobreescrevendo o metodo pai, say()
    @Override
    public void say()
    {
        System.out.println("cat says: meow meow!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal;

        myAnimal = new Dog();
        myAnimal.say(); // dog says: woof woof!

        myAnimal = new Cat();
        myAnimal.say(); // cat says: meow meow!
    }
}
```

</script>
</zero-md>
<!-- ARTICLE END -->

<footer>
    <a href="../../papers.html">
        <p id="footer-text">0xDant &copy; 2023</p>
    </a>
</footer>

</body>
</html>
