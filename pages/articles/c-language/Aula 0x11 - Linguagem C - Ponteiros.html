<!-- CREATE TOPIC DIRECTORY, THE LANGUAGE, THE TITLE AT HEAD AND WRITE YOUR PAPER OR USE THE SCRIPT TO AUTOMATE PROCCESS! -->

<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../../assets/css/markdown.css">
    <link rel="shortcut icon" href="../../../assets/images/sterile-box.ico">
    <title>Void | C Language</title>

    <script type="module">
        import ZeroMd, { STYLES } from 'https://cdn.jsdelivr.net/npm/zero-md@3'
      
        customElements.define('zero-md', class extends ZeroMd {
          async load() {
            await super.load()
            this.template = STYLES.preset('dark')
          }
        })
    </script>
</head>
<body>

<header>
    <a href="../../papers.html">
        <p id="footer-text">0xDant &copy; 2023</p>
    </a>
</header>

<!-- ARTICLE BEGIN -->
<zero-md>
<script type="text/markdown">

# Aula 11 - Linguagem C - Ponteiros

## Introducao

- É uma variável especial que armazena endereços de memória ao invés de valores comuns e são declaradas como ponteiros.

```c
// declaração
pointer_type * pointer_name;

/*
	!!DICA PARA ASSIMILAÇÃO!!
	
	// & corta com *

	*(x + i) == x[i]
	
	&[*(x + i)] == &{x[i]}
	
	(x + i) == &x[i]
	
	// portanto
	
	// &x[i]
    x + i
    // x[i]
    *(x + i)
*/

// exemplo de uso
int i = 10;
int * p;
// o ponteiro p recebe o endereço da variável i
p = &i;
// output's
printf("O endereço de i eh: %p\n", &i);
printf("O endereço de p (mesmo de i) eh: %p\n\n", p);
printf("O valor de i eh: %d\n", i);
printf("O valor de p (mesmo de i) eh: %d\n\n", *p);
// toda e qualquer alteração feita em p/i irá acontecer em i/p:
*p = 1;
printf("O valor de i eh: %d\n", i);
printf("O valor de p (mesmo de i) eh: %d\n\n", *p);

/*
	%p ->> para formatação
    &  ->> operador de endereço de memoria
	*  ->> operador de indireção / deferência
	
	curiosidades:
		(void*)0 == NULL;
		
		s[0] == 0[s]
	
	obs:
		o operador "*" "cancela" com o operador "&"!
		ex:
			p  = &i .:. *p = i
	
	!!IMPORTANTE!!
	
	char a[] = "teste";
	
	printf("%c", a[i]);
	
	// mesmo que:
	
	printf("%c", *(a + i));
	
	
	// o operador [] é um atalho de *!
*/
```

- Observações:
	- `*a + 1` != `*(a + 1)`
		- `*a` retorna o 1° elemento do array, assim, `*a + 1` = 1° elemento + 1;
		- Quanto a `a`, se a é `0x7fff83234`, temos `a+1` = `0x7fff83238`.
	- `char *s = "texto"` != `char s[] = "texto";` != `char (*s)[]`:
		- Isso porque quando você define o valor de um ponteiro para um `const char`, na verdade você está definindo o **ENDEREÇO** dessa string constante para o ponteiro;
		- Porém as `const char` ficam na seção de ROM, portanto, não podem ser alteradas;
		- Os ponteiros apontam para um único char, não para arrays. 
	- Ponteiros de **indireção Múltipla** (ponteiros para ponteiros):
		- Quando um ponteiro aponta para outro e até que enfim aponta para algum valor (ou ainda em outro ponteiro);
		- Usamos:
    		- `pointer_type **varName;`, onde o `*` é relativo ao numero de indireções.

- estrutura simples para uso de argumentos:

```c
int main(int argc, char *argv[]){}

/*
- caso o argv[x] onde x > n° de argumentos passados, 
  o programa acaba pegando as variaveis de ambiente 
  (acaba "virando" um envp[x] no lugar de *argv[])

- char *argv[]   ->> array de ponteiros para char
- char (*argv)[] ->> ponteiro para um array de chars.
- char **argv    ->> ponteiro para um ponteiro para char.
- char **argv / char *argv[] 
	-> são intercambiáveis, mas apenas como argumentos de funções.
*/
```

## Ponteiro para função

- Tópico pouco falado mas que pode ser utilizado em projetos avançados.

```c

// DECLARAÇÃO
// return_type (* var_name)(params_type)

// exemplo 0x01

int add(int a, int b) {
    return a + b;
}

int sub(int a, int b) {
    return a - b;
}

int exemplo1(void) {

	int (*func)(int, int) = add;

	/*
		int (*func)(int);
		func = sqrt;
	*/

	printf("Função 1: %d\n", func(5, 5));

    func = sub;
    printf("Função 2: %d\n", func(5, 5));
	
	return 0;
}

/*
	OUTPUT:
	
	Função 1: 10
	Função 2: 0
*/

// exemplo 0x02
// reformulação do 1° exemplo, com typedef
typedef int (*Operacao)(int, int);

int exemplo2(void) {

    Operacao op;

    op = add;
    printf("Função 1: %d\n", op(5, 5));

    op = sub;
    printf("Função 2: %d\n", op(5, 5));
	
	return 0;
}

// exemplo 0x03
// variação do 2° exemplo, com vetores
int exemplo3(void) {

    Operacao op[2];

    op[0] = add;
    printf("Função 1: %d\n", op[0](5, 5));

    op[1] = sub;
    printf("Função 2: %d\n", op[1](5, 5));
	
	return 0;
}
```

## Referências

- https://www.ic.unicamp.br/~rafael/cursos/2s2017/mc202/valgrind.html

</script>
</zero-md>
<!-- ARTICLE END -->

<footer>
    <a href="../../papers.html">
        <p id="footer-text">0xDant &copy; 2023</p>
    </a>
</footer>

</body>
</html>
