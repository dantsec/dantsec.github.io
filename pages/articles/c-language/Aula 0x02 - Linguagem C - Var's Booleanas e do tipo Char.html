<!-- CREATE TOPIC DIRECTORY, THE LANGUAGE, THE TITLE AT HEAD AND WRITE YOUR PAPER OR USE THE SCRIPT TO AUTOMATE PROCCESS! -->

<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../../assets/css/markdown.css">
    <link rel="shortcut icon" href="../../../assets/images/sterile-box.ico">
    <title>Void | C Language</title>

    <script type="module">
        import ZeroMd, { STYLES } from 'https://cdn.jsdelivr.net/npm/zero-md@3'
      
        customElements.define('zero-md', class extends ZeroMd {
          async load() {
            await super.load()
            this.template = STYLES.preset('dark')
          }
        })
    </script>
</head>
<body>

<header>
    <a href="../../papers.html">
        <p id="footer-text">0xDant &copy; 2023</p>
    </a>
</header>

<!-- ARTICLE BEGIN -->
<zero-md>
<script type="text/markdown">

# Aula 02 - Linguagem C - Var's Booleanas e do tipo Char

## Algumas Considerações

1. O operador __sizeof__ retorna o tipo __size_t__, definido em __<stdlib.h>__. Esse tipo tem o **tamanho de um ponteiro** (na arquitetura i386 têm 4 bytes de tamanho, na arquitetura x86-64, 8 bytes);
2. Existe uma extensão para os especificadores de coversão do _printf_ (as substrings começadas com %) que pode ser usada para quando queremos imprimir o valor expresso no tipo size_t. Ao invés de usar __%lu__, podemos usar __%zu__ - garantindo a __compatibilidade__ com a __arquitetura vigente__. Isso existe porque o tipo __long__ no Windows, por exemplo, tem 4 bytes de tamanho (32 bits), mas no "Linux" e outros UNIXes, ela tem 8 bytes;
3. Um caracter literal, como `'A'`, por exemplo, tem o tamanho de um int, não de um char. Isso é fácil demonstrar usando o operador sizeof('A'), por exemplo (e você obterá 4!).

Quando fazemos:

```c
char c;

printf("%d e %d e %d", sizeof(c), sizeof('A'), sizeof("A"));
// OUTPUT: 1 e 4 e 2

// O inteiro 'A' é convertido para char
// mantendo apenas os 8 bits inferiores.
```

Isso é diferente da "string" literal, onde cada item tem 1 byte de tamanho, exceto se usamos prefixos como L, u, U ou u8 (no caso do C11).

4. Outra dica sobre os conversores _d_ e _u_ do _printf_ é que, assim como o modificador 'l' pode ser usado como prefixo para a conversão (como no caso de %lu para 'long unsigned int'), os prefixos 'hh' e 'h' são definidos na especificação C99;
    - O conversor "%hhd" espera o argumento do tipo "char" e um "%hd" do tipo "short";
    - Os prefixos _*"hh", "h", "l" e "ll"*_ não são "extensões", mas fazem parte do padrão.

## Booleanos

- O tipo **bool** é um **"apelido"** para o tipo **Bool**, definido na especificação C99;
- Se não quiser incluir o header stdbool.h, basta substituir "bool" por "_Bool_";

```c
#define bool  _Bool
#define true  1
#define false 0
```

-  A especificação da linguagem C nos diz que uma expressão BOOLEANA sempre resulta em 0 ou 1, mas a avaliação de um valor booleano é feita **contra o ZERO**. Ou seja, se o valor do booleano for -10, por exemplo, ele será TRUE;
- O tipo "`_Bool`", nesse sentido, é especial porque apenas o bit 0 é considerado, exemplo:
	- `bool b = -10; //out: 1`.

## Referências:

- https://www.tutorialspoint.com/c_standard_library/limits_h.htm
- https://www.tutorialspoint.com/cprogramming/c_bit_fields.htm

</script>
</zero-md>
<!-- ARTICLE END -->

<footer>
    <a href="../../papers.html">
        <p id="footer-text">0xDant &copy; 2023</p>
    </a>
</footer>

</body>
</html>
