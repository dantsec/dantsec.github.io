<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../../assets/css/markdown.css">
    <link rel="shortcut icon" href="../../../assets/images/sterile-box.ico">
    <title>Void | C Language</title>

    <script type="module" src="https://cdn.jsdelivr.net/npm/zero-md@3?register"></script>
</head>
<body>

<header>
    <a href="../../papers.html">
        <p id="footer-text">0xDant &copy; 2023</p>
    </a>
</header>

<!-- ARTICLE BEGIN -->
<zero-md>
<script type="text/markdown">

# Aula 05 - Linguagem C - Vetores (Arrays)
- Estrutura de dados **Unidimensional e Homogênea**
    - Os índices vão de 1 em 1, mas, em memória, irão variar de acordo com o tamanho do tipo da variável (de 4 em 4 se for um tipo int, por exemplo)  
- Como ver o tamanho de um array:
```c
// tamanho = (tamanho da variável)bytes * quantidade de elementos
// em código:
int c[3];

printf("O tamanho de c eh: %zu", sizeof c);

// pegar número de elementos
printf("O tamanho de c eh: %zu", sizeof c / sizeof c[0]);
printf("O tamanho de c eh: %zu", sizeof c / sizeof(int));
```
- Informações do array:
```c
long int c[3];

// mostra o endereço onde a variável foi alocada
// aponta direto no endereço do 1o elemento
printf("%p\n", c);
printf("%p\n", &c);
printf("%p\n", &c[0]);
// endereço de &c[0] + 8 (tamanho de cada elemento)
printf("%p\n", &c[1]);
// conteudo do endereço de memoria[4] -> out: 0 ou numero randomico (lixo) 
// pois no endereço que ele está acessando, não definimos nada.
printf("%ld\n", c[4]);
// endereço de c[4]
printf("%p\n", &c[4]);
```
- Também podemos escrever arrays da seguinte forma(exemplo):
```c
//No lugar de ficar declarando uma por uma.
float a[3] = {7, 11.8, 12}; 
```

- O GCC usa, automaticamente, uma versão modificada da C99 chamada GNU99. Se quiser usar a C11 (ou a GNU11, versão modificada da C11), acrescente a opção: `std=c11 ou -std=gnu11`, na linha de comando.
    - PS: A GNU99 é, basicamente, a C11. Não confundir o padrão C11 com o C++11. C++ != C.

- Quanto à "confusão" entre arrays e ponteiros, ela não existe. A especificação C99 (e as anteriores, bem como a C11) nos diz, no item 6.5.2.1: 
    - "One of the expressions shall have type of a 'pointer to object type', the other expression shall have integer type, and the result is type 'type'".
    - "Uma das expressões deve ter o tipo 'ponteiro para o tipo de objeto', a outra expressão deve ter o tipo inteiro, e o resultado é o tipo 'tipo'". Ou seja:
        - `type pointer[integer];`
    - Por isso, é meio perigoso o uso de __&c__ para obter o ponteiro do primeiro item. A especificação "parece" definir &c, como no exemplo, como __"undefined behavior"__. Ou seja, é bom evitá-la.

## Referências:

    - Especificação ISO 9899:1999 (C99): http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf
    - Especificação ISO 9899:2011 (C11 - a mais atual): http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.

</script>
</zero-md>
<!-- ARTICLE END -->

<footer>
    <a href="../../papers.html">
        <p id="footer-text">0xDant &copy; 2023</p>
    </a>
</footer>

</body>
</html>