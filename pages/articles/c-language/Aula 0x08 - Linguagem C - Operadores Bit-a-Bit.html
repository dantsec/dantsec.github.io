<!-- CREATE TOPIC DIRECTORY, THE LANGUAGE, THE TITLE AT HEAD AND WRITE YOUR PAPER OR USE THE SCRIPT TO AUTOMATE PROCCESS! -->

<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../../assets/css/markdown.css">
    <link rel="shortcut icon" href="../../../assets/images/sterile-box.ico">
    <title>Void | C Language</title>

    <script type="module">
        import ZeroMd, { STYLES } from 'https://cdn.jsdelivr.net/npm/zero-md@3'
      
        customElements.define('zero-md', class extends ZeroMd {
          async load() {
            await super.load()
            this.template = STYLES.preset('dark')
          }
        })
    </script>
</head>
<body>

<header>
    <a href="../../papers.html">
        <p id="footer-text">0xDant &copy; 2023</p>
    </a>
</header>

<!-- ARTICLE BEGIN -->
<zero-md>
<script type="text/markdown">

# Aula 08 - Linguagem C - Operadores Bit-a-Bit

```c
/*
	&  - E, AND
	|  - OU, OR
	^  - OU EXCLUSIVE, EXCLUSIVE OR (XOR)
	~  - NÃO, NOT (complemento de 1)
	<< - LEFT SHIFT
	>> - RIGHT SHIFT
*/
```

```c
// LEFT / RIGHT SHIFT

/*
	0b - prefixo para binário
	0x - prefixo para decimal
*/

int a = 0b1000; // 8 (base 10)

// 10000 (2) = 16 (10) 
printf("O resultado eh: %d\n", a << 1);

// 0100 (2)  = 4  (10) 
printf("O resultado eh: %d\n", a >> 1);
```

## Notas:

- A notação `0b` para tipos literais em binário é uma **EXTENSÃO** de alguns compiladores. Não faz parte do padrão, melhor não usar. Prefira a notação hexadecimal ou octal;
- Atenção para um problema em potencial com o SHIFT para a direita (`>>`). C não faz distinção entre SHIFT LÓGICO e SHIFT ARITMÉTICO. O segundo leva em consideração o bit de mais alta ordem do valor (o bit de sinal) se o tipo for sinalizado;
	- Isso significa que `>>` pode tanto ser traduzido pelo compilador por um shift lógico ou aritmético, o que pode resultar algo diferente do esperado;
	- A especificação nos diz que, neste caso, é "dependente de implementação".
  - **SHIFT LÓGICO** sempre complementa com **zeros**. **SHIFT ARITMÉTICO** copia o bit de mais alta ordem;
	  - Ambos quando o shift é feito para a direita. No shift para a esquerda ambos os shifts também existem, mas causam sempre a inserção de zeros à direita.
	- Então evite usar shifts com tipos sinalizados (char, short, int, long e long long). Prefira os tipos "__unsigned__" (onde o __SHIFT ARITMÉTICO jamais será usado__).

### Comparação detalhada

| Operação                | Com sinal (`signed`)                             | Sem sinal (`unsigned`) |
| ----------------------- | ------------------------------------------------ | ---------------------- |
| Shift lógico (`>>`)     | Comportamento não definido (não usa em `signed`) | Preenche com 0         |
| Shift aritmético (`>>`) | Preenche com o bit de sinal (mantém o sinal)     | Não aplicável          |
| Shift à esquerda (`<<`) | Mesmo comportamento, mas cuidado com overflow    | Preenche com 0         |

## Referências

- https://www.embarcados.com.br/bits-em-linguagem-c/

</script>
</zero-md>
<!-- ARTICLE END -->

<footer>
    <a href="../../papers.html">
        <p id="footer-text">0xDant &copy; 2023</p>
    </a>
</footer>

</body>
</html>
