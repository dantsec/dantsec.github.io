<!-- CREATE TOPIC DIRECTORY, THE LANGUAGE, THE TITLE AT HEAD AND WRITE YOUR PAPER OR USE THE SCRIPT TO AUTOMATE PROCCESS! -->

<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../../assets/css/markdown.css">
    <link rel="shortcut icon" href="../../../assets/images/sterile-box.ico">
    <title>Void | PHP</title>

    <script type="module">
        import ZeroMd, { STYLES } from 'https://cdn.jsdelivr.net/npm/zero-md@3'
      
        customElements.define('zero-md', class extends ZeroMd {
          async load() {
            await super.load()
            this.template = STYLES.preset('dark')
          }
        })
    </script>
</head>
<body>

<header>
    <a href="../../papers.html">
        <p id="footer-text">0xDant &copy; 2023</p>
    </a>
</header>

<!-- ARTICLE BEGIN -->
<zero-md>
<script type="text/markdown">

# Linguagem PHP: 0x13 - Web

## Variaveis Globais

- Uma das principais eh o **\$_SERVER**:
	- _SERVER_SOFTWARE_: identificacao do servidor;
	- _SERVER_NAME_: hostname, DNS / IP do servidor;
	- _SERVER_PROTOCOL_: protocolo do servidor;
	- _SERVER_PORT_: porta do servidor;
	- _QUERY_STRING_: argumentos apos o `?` na url;
	- _REQUEST_METHOD_: qual verbo a requisicao utilizou.
- E junto dela temos **\$_GET**, **\$_POST** e **$_FILES**.

## Redirect

- Permite redirecionar o navegador para uma URL diferente;
- Usamos nos seguintes casos:
	- Mudar o nome de dominio do site;
	- Substituir a URIL da pagina por outra;
	- Melhoria de HTTP para HTTPS.

```php
/*
	header(
		string $header,
		bool $replace = true,
		int $response_code = 0
	): void
*/

header(
	'Location: https://www.phptutorial.net/about-us.php',
	true,
	301
);
```

## Processamento de Dados

### Formularios

- Podemos fazer de duas maneiras, ou com _POST_ ou com _GET_;
- Com o _GET_, processaremos os parametros via **QUERY_STRING**;
- Com o _POST_, processaremos dados via payload do request (**Form Data**).

#### Filtragem e Sanitizacao de Dados

- `filter_has_var(int $inpType, string $varName): bool`: usada para checar se uma variavel existe no input;
	- Tipos de input validos: `INPUT_GET`, `INPUT_POST`, `INPUT_COOKIE`, `INPUT_SERVER`, e `INPUT_ENV`;
	- Sua principal diferenca para o `isset()` eh que ele verifica realmente os dados que vem de uma requisicao do tipo especificado.

```php
// Vindo de um Formulario
if (filter_has_var(INPUT_POST, 'name')) {
	echo 'Exists:' . htmlspecialchars($_POST['name']);
} else {
	echo 'The name is required!';
}
```

- `filter_var($value, $filter = FILTER_DEFAULT, array|int $options = 0)`: usada para sanitizar (limpar e preparar os dados) e validar dados;
	- O `$value` eh o valor a ser filtrado, `$filter` eh o metodo de filtragem e `$options` eh um array associativo de flags separados por pipelines;
	- Caso filtrado corretamente, retorna o valor, caso contrario, retorna falso.

```php
if (filter_has_var(INPUT_GET, 'id')) {
	/*
		`filter_var()` converte implicitamente str p/ int.
	*/

	// sanitize
	$clean_id = filter_var(
		$_GET['id'],
		FILTER_SANITIZE_NUMBER_INT
	);

	if ($clean_id) {
		// validate
		$id = filter_var($clean_id, FILTER_VALIDATE_INT);
	
		// show
		echo $id === false
			? 'must be at least 10'
			: $id;
	} else {
		echo 'id is invalid'
	}
} else {
	echo 'id is required.';
}
```

- `filter_input($type, $name, $filter, $options): mixed`: permite pegarmos uma variavel externa pelo nome e seus filtros;
	- Os valores de retorno sao `null` (`$name` nao esta setada), `false` (falha na filtragem) e o valor filtrado caso tudo ocorra bem;
	- Faz o mesmo que `filter_var`, porem, ao inves de apenas retornar uma string vazia caso haja erro, essa funcao retorna nulo, evitando possiveis erros e evitando o uso do `filter_has_var`. Tudo em uma jogada so.

### Encode de URL

- Para processarmos dados vindos de uma url / querystring podemos usar as funcoes `urlencode($string)` e `urldecode($string)`;
	- A primeira encoda uma string comum para uma utilizavel via url;
	- A segunda decode uma string tipo url em um formato padrao.

```php
# urlencode()
$userinput = 'Data123!@-_ +';
$encoded = '<a href="mycgi?foo=' . urlencode($userinput) . '">';

echo $encoded;
// <a href="mycgi?foo=Data123%21%40-_+%2B">

# urldecode()
$decoded = urldecode($encoded);

echo $decoded;
// <a href="mycgi?foo=Data123!@-_ +">
```

### Leitura do Corpo da Requisicao

- Tecnicamente o PHP so aceita requisicoes do tipo `GET` e `POST`, e para lermos conteudos providos de outros verbos HTTP devemos utilizar o _input wrapper_.

```php
// Maneira 1:
fopen('php://input', 'r');

// Maneira 2:
json_decode(
    file_get_contents('php://input'),
	true
);
```

### Seguranca

#### Hash de Senhas

- Para melhorar a seguranca da nossa aplicacao, ao utilizar sistemas autenticacao que usam senhas, devemos fazer o **hash** delas, e para isso podemos usar as funcoes `password_hash` (criptografar) e `password_verify` (comparar a senha original e a de entrada), que utiliza o algoritmo _BCrypt_.

#### Filtragem e Validacao de Dados

- Nunca devemos confiar nas entradas externas feitas ao nosso codigo PHP, por isso devemos sanitizar e validar as entradas antes de utiliza-las em codigo;
- As funcoes `filter_var` e `filter_input` podem higienizar textos e validar formatos (ex: enderecos de email);
- Outro cenario eh quando argumentos externos sao passados para execucao em linha de comando, e eh interessante filtrarmos a entrada com `escapeshellarg`.

## File Upload com PHP

- Para enviar arquivos ao servidor, precisamos de um _form_ e de alguns requisitos:
	- Setar o `enctype` para `multipart/form-data`;
	- O tipo de `input` do form deve ser `file`;
	- O processamento eh feito pela variavel global `$_FILES` (no lado do servidor).
- Boas praticas:
	- Verifique o tipo _MIME_ e a extensao do arquivo para garantir que apenas arquivos permitidos sejam enviados. Nao confie apenas na extensao, pois ela pode ser facilmente modificada;
	- Limite o tamanho do arquivo, definindo um tamanho maximo para os arquivos enviados;
		- `upload_max_filesize` e `post_max_size`;
		- `$_FILES['file']['size'] > ALLOWED_SIZE` (medido em bits).
	- Sanitize o nome do arquivo removendo ou substituindo caracteres perigosos para evitar problemas de seguranca e compatibilidade.
		- Utilize `basename()` para garantir que o caminho do arquivo nao seja manipulado.
	- Verifique se ocorreram erros no upload, por aqui: `$_FILES['file']['error']`;

```php
<?php

$upload_dir = 'uploads/';

// Verifica se o diretorio existe, se nao, cria
if (!is_dir($upload_dir)) {
    mkdir($upload_dir, 0777, true);
}

if ($_SERVER['REQUEST_METHOD'] == 'POST') {
    // Verifica se ha arquivo para upload
    if (isset($_FILES['file']) && $_FILES['file']['error'] === UPLOAD_ERR_OK) {
        // Verifica o tipo de arquivo permitido
        $allowed_types = ['image/jpeg', 'image/png', 'application/pdf'];

        // Verifica o tipo MIME real do arquivo
        $finfo = finfo_open(FILEINFO_MIME_TYPE);
        $mime_type = finfo_file($finfo, $_FILES['file']['tmp_name']);
        finfo_close($finfo);

        if (!in_array($mime_type, $allowed_types)) {
            die("Tipo de arquivo não permitido.");
        }

        // Limite de tamanho
        if ($_FILES['file']['size'] > 2000000) {
            die("Arquivo muito grande. Limite de 2MB.");
        }

        // Sanitiza o nome do arquivo
        $filename = basename($_FILES['file']['name']);
        $safe_filename = preg_replace("/[^a-zA-Z0-9_-]/", "_", $filename);

        // Move o arquivo para o diretorio de destino
        $target_path = $upload_dir . $safe_filename;

        if (move_uploaded_file($_FILES['file']['tmp_name'], $target_path)) {
	        // Define permissoes seguras
            chmod($target_path, 0644);

			echo "Sucesso! Arquivo salvo em: " . $target_path;
        } else {
            $error = error_get_last();
            echo "Erro ao mover o arquivo: " . $error['message'];
        }
    } else {
        echo "Erro no upload do arquivo.";
    }
}

?>

<!-- Formulário HTML -->
<form action="" method="POST" enctype="multipart/form-data">
    <label for="file">Escolha um arquivo:</label>
    <input type="file" name="file" id="file">
    <button type="submit">Enviar</button>
</form>
```

## Mantendo o Estado (state)

- O HTTP eh um protocolo que nao mantem seu estado (_stateless_), isso significa que apos o fim de uma requisicao a conexao entre usuario e servidor eh finalizada, e a proxima conexao nao possui mais relacao com a anterior;
- Para conseguir manter o estado e preservar os dados, podemos utilizar os **COOKIES** ou as **SESSIONS**;
	- Atualmente as _sessions_, mesmo que utilizando as tecnicas dos _cookies_, sao mais utilizadas, pois servem para armazenar dados mais triviais;
	- Importante ressaltar que ambas as abordagens devem dar-se logo no inicio do script PHP!

### Cookies

- Sao strings que contem informacoes e sao **salvas no navegador do usuario**;
- A funcao para adicionar um cookie eh a `setcookie()`;
- Os valores podem ser resgatados com a variavel global `$_COOKIES`;
- Boas praticas:
	- Definir o tempo de expiracao;
	- Cookies seguros, marque-os como `HttpOnly` para evitar acessos via javascript, e como `Secure` para garantir que sejam transmitidos apenas em conexoes HTTPS;
	- Nao armazene dados sensiveis nos cookies;
	- Utilize criptografia.

```php
<?php

define('MONTH', 60 * 60 * 24 * 30);

// Setando um cookie por um periodo de 30 dias
setcookie('idioma', 'pt_br', time() + MONTH);

// Consultando valor fixo:
// isset($_COOKIE['foo']) && $_COOKIE['foo'] == 'bar'

// Em outra pagina, verificamos se o cookie existe
if (isset($_COOKIE['idioma'])) {
	echo "Idioma selecionado: " . $_COOKIE['idioma'];
} else {
	echo "Nenhum idioma selecionado.";
}

// Deletando o Cookie
unset($_COOKIE['idioma']);
setcookie('idioma', null, time() - 3600);
```

### Sessions

- Sao usadas para _autenticacao_, _carrinhos de compras_, e tudo que precisar persistir entre paginas e tambem por algum tempo;
- Sao **salvas em arquivos no servidor** da aplicacao;
	- O _path_ pode ser encontrado em: `php.ini` > `session.save_path`;
	- Para identificacao, as sessoes utilizam IDs, que por sua vez sao armazenadas em cookies (`PHPSESSID`);
		- Uma vez que usamos esse cookie, devemos chamar `session_start()` toda vez que queiramos utilizar as sessoes.
- Alem disso, podem ser salvas em dois formatos:
	- O do proprio PHP;
	- Web Distributed Data eXchange (WDDX).
- Boas praticas:
	- Regenerar o ID da sessao (`session_regenerate_id()`) apos eventos criticos (como login) a fim de evitar o ataque de _session hijacking_;
	- Definir um tempo de expiracao;
	- Evitar guardar informacoes sensiveis em sessoes.

```php
<?php

// Cria uma sessao ou busca uma caso ja exista
session_start();

// Usuario fez login com sucesso
$_SESSION['user_id'] = 1;
$_SESSION['username'] = 'joao';

// Em uma pagina diferente, verificamos se o usuario esta logado
if (isset($_SESSION['user_id'])) {
	echo "Bem-vindo, " . $_SESSION['username'];
} else {
	echo "Por favor, faça login.";
}

// [ Destruindo a sessao ]

// Deleta os dados associados com a sessao atual
session_destroy();

// Mas nao faz o `unset` dos dados no array e nos cookies
// Para isso eh necessario fazer:
if (isset($_COOKIE[session_name()])) {
	setcookie(session_name(),'',time() - 3600, '/');
}

$_SESSION[] = [];

session_destroy();
```

## PHP dentro do HTML

- Antes de tudo, e importante dizer que nao eh uma boa pratica colocar muito codigo php dentro do html, pois deixa a aplicacao mais dificil de escalar e de fazer manutencao;
- Assim, e importante conhecermos a **SoC** (**Separation of Concerns**), que eh, em resumo, deixar tudo separadinho, ex:

```php
%% Ao inves de fazer isso: %%

// index.php
<!DOCTYPE html>
<html lang="en">
	<body>
		<?php $title = 'PHP is awesome!'; ?>
		<h1><?= $title; ?></h1>
	</body>
</html>


%% Faca isso: %%

// index.php
<?php
	$title = 'PHP is awesome!';
	require 'index.view.php';

// index.view.php
<!DOCTYPE html>
<html lang="en">
	<body>
		<h1><?= $title; ?></h1>
	</body>
</html>
```

- Para finalizar, temos algumas palavras reservadas usadas para esse fim:

```php
1. if - else - elseif - endif
2. while - endwhile
3. for - endfor
4. foreach - endforeach
5. switch - endswitch
6. try - catch - finally
7. declare - enddeclare
8. function - endfunction
9. class - endclass
A. interface - endinterface
B. trait - endtrait
```

</script>
</zero-md>
<!-- ARTICLE END -->

<footer>
    <a href="../../papers.html">
        <p id="footer-text">0xDant &copy; 2023</p>
    </a>
</footer>

</body>
</html>
