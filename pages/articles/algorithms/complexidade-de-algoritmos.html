<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../../assets/css/markdown.css">
    <link rel="shortcut icon" href="../../../assets/images/sterile-box.ico">
    <title>Void | Algorithms</title>
</head>
<body>

<header>
    <a href="../../papers.html">
        <p id="footer-text">0xDant &copy; 2023</p>
    </a>
</header>

<!-- ARTICLE BEGIN -->
<github-md>

# Aula 06 - Algoritmos - Complexidade de Algoritmos

### Notação Big-O

- Trata do comportamento assintótico de funções
- Cheat Sheet: https://www.bigocheatsheet.com/

#### Como encontrar a Complexidade?
- Serão 3 passos:
    - P1: Levar em Consideração apenas as iterações
    - P2: Verificar a complexidade das funções/métodos na linguagem (se utilizada)
    - P3: Ignorar constantes e utilizar termo de maior valor
- Conceitos:
    - N é o valor de entrada
    - Sempre consideramos log na base 2
    - 1 segundo ~ 10^8 operações
- Melhor para Pior:
```
O(1) - Constante
O(N) - Linear
O(logN)
O(N^2)
O(N^3)
O(2^N)
O(N!)
```

### Exemplos Comentados

```cpp
bool example1(vector<int> v, int X) {
    int tamanho = v.size() // O(1)
    
    for(int i = 0; i < tamanho; i++) // O(N)
        if(v[i] == X)
            return true;
    
    return false; 
}

/*
    Complexidade Linear -> O(N)
*/
```

```cpp
bool example2(vector<int> v) {
    int tamanho = v.size() // O(1)
    
    for(int i = 0; i < tamanho; i++) // O(N)
        for(int j = 0; j < tamanho; j++) // O(N)
            if(i != j && v[i] == v[j])
                return true;
    
    return false; 
}

/*
    Complexidade Quadrática -> O(N) * O(N) = O(N^2)
*/
```

```cpp
int example3(vector<int> v) {
    int tamanho = v.size() // O(1)
    int bla = 0;
    
    for(int i = 0; i < tamanho; i++) // O(N)
        for(int j = 0; j < tamanho; j++) // O(N)
            if(i != j && v[i] == v[j])
                bla++;
    
    int ble = 0;
    for(int i = 0; i < tamanho; i++) // O(N)
        if(v[i] == 10)
            ble = 2 * ble;
    
    int bli = 0;
    for(int i = 0; i < tamanho; i++) // O(N)
        if(v[i] == 5)
            bli += 5;
    
    return bla + ble + bli;
}

/*
    P1 & P2
        [O(N) * O(N)] + O(N) + O(N) = O(N^2) + 2 * O(N)
    
    P3
        O(N^2) + O(N)
        O(N^2)
    
    Complexidade Quadrática -> O(N^2)
*/
```

```cpp
bool exemple4(vector<int> v, vector<int> w) {
    int tamanho1 = v.size();
    int tamanho2 = w.size();
    
    for(int i = 0; i < tamanho1; i++) // O(N)
        for(int j = 0; j < tamanho2; j++) // O(M)
            if(v[i] == v[j])
                return true;
    
    return false;
}

/*
    Complexidade -> O(N) * O(M)
*/
```

```cpp
/*
    Ambos os exemplos fazem a mesma coisa!
*/

bool example5(vector<int> idades) {
    int tamanho = idades.size(); // O(1)
    int menor_idade = 200;
    
    for(int i = 0; i < tamanho; i++) // O(N)
        if(idades[i] < menor_idade)
            menor_idade = idades[i];
    
    int cont = 0;
    for(int i = 0; i < tamanho; i++) // O(N)
        if(v[i] == menor_idade)
            cont++;
    
    return cont > 1;
}

/*
    P1 & P2
        O(N) + O(N) = 2 * O(N)
    
    P3
        Complexidade Linear = O(N)
*/

bool example6(vector<int> idades) {
    sort(idades.begin(), idades.end()); // O(N * logN)
    return idades[0] == idades[1];
}

/*
    Complexidade NlogN = O(N * logN)
*/
```

```cpp
bool example7(set<int> s, vector<int> v) {
    int tamanho = v.size();
    for(int i = 0; i < tamanho; i++) // O(N)
        if(s.count(v[i])) // O(logN)
            return true;
    
    return false;
}

/*
    O(N) * O(logN) = O(N * logN)
    
    Complexidade NlogN = O(N * logN)
*/
```

### Notação Big-Ω

- Quando uma função _f(n)_ é limitada inferiormente por outra função _g(n)_, dizemos que a **complexidade de tempo / espaço** de _f(n)_ é _Ω_( _g(n)_ ).
    - Significa que a função _f(n)_ nunca será mais rápida (menor) do que a função _g(n)._
        - Descrito como o "melhor caso"
        - Esta é a interpretação da **Notação** **Ω**.

### Notação Big-Θ

- Descreve o comportamento assintótico de funções definindo ao mesmo tempo um limite superior e um inferior para a execução de determinado algoritmo.
    - **Θ( g(n) )** é a **interseção** entre **O( g(n) )** e **Ω( g(n) )**.

</github-md>
<!-- ARTICLE END -->

<footer>
    <a href="../../papers.html">
        <p id="footer-text">0xDant &copy; 2023</p>
    </a>
</footer>

<script src="../../../assets/js/markdown-tag-GitHub.js"></script> 

</body>
</html>