<!-- CREATE TOPIC DIRECTORY, THE LANGUAGE, THE TITLE AT HEAD AND WRITE YOUR PAPER OR USE THE SCRIPT TO AUTOMATE PROCCESS! -->

<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../../assets/css/markdown.css">
    <link rel="shortcut icon" href="../../../assets/images/sterile-box.ico">
    <title>Void | Algorithms</title>

    <script type="module">
        import ZeroMd, { STYLES } from 'https://cdn.jsdelivr.net/npm/zero-md@3'
      
        customElements.define('zero-md', class extends ZeroMd {
          async load() {
            await super.load()
            this.template = STYLES.preset('dark')
          }
        })
    </script>
</head>
<body>

<header>
    <a href="../../papers.html">
        <p id="footer-text">0xDant &copy; 2023</p>
    </a>
</header>

<!-- ARTICLE BEGIN -->
<zero-md>
<script type="text/markdown">

# Aula 06 - Algoritmos - Complexidade de Algoritmos

## Tipos de Notacao

### Notacao Big-O

- Trata do comportamento assintotico de funcoes;
- Cheat Sheet: https://www.bigocheatsheet.com/.
### Notacao Big-Ω

- Quando uma funcao _f(n)_ éh limitada inferiormente por outra função _g(n)_, dizemos que a **complexidade de tempo / espaço** de _f(n)_ eh **Ω( g(n))**.
- Significa que a funcao _f(n)_ nunca sera mais rapida (menor) do que a funcao _g(n)_;
	- Descrito como o "melhor caso";
	- Esta é a interpretação da **Notação Ω**.

### Notação Big-Θ

- Descreve o comportamento assintotico de funcoes definindo ao mesmo tempo um limite superior e um inferior para a execucao de determinado algoritmo.
	- **Θ(g(n))** eh a **interseccao** entre **O(g(n))** e **Ω(g(n))**.

## Como encontrar a Complexidade?

- Serao 3 passos:
	- **P1**: Levar em consideracao apenas as iteracoes;
	- **P2**: Verificar a complexidade das funcoes / metodos na linguagem (se utilizada);
	- **P3**: Ignorar constantes e utilizar termo de maior valor.
- Conceitos:
	- N eh o valor de entrada;
	- Sempre consideramos **log na base 2**;
	- **1 segundo ~ 10^8 operações**.
- Melhor para Pior:

```
O(1) - Constante
O(N) - Linear
O(logN)
O(N^2)
O(N^3)
O(2^N)
O(N!)
```

### Exemplos Comentados

```cpp
bool example1(vector<int> v, int X) {
	int tamanho = v.size() // O(1)
	
	for(int i = 0; i < tamanho; i++) // O(N)
		if(v[i] == X)
			return true;
	
	return false; 
}

/*
	Complexidade Linear -> O(N)
*/
```

```cpp
bool example2(vector<int> v) {
	int tamanho = v.size() // O(1)
	
	for(int i = 0; i < tamanho; i++) // O(N)
		for(int j = 0; j < tamanho; j++) // O(N)
			if(i != j && v[i] == v[j])
				return true;
	
	return false; 
}

/*
	Complexidade Quadrática -> O(N) * O(N) = O(N^2)
*/
```

```cpp
int example3(vector<int> v) {
	int tamanho = v.size() // O(1)
	int bla = 0;
	
	for(int i = 0; i < tamanho; i++) // O(N)
		for(int j = 0; j < tamanho; j++) // O(N)
			if(i != j && v[i] == v[j])
				bla++;
	
	int ble = 0;
	for(int i = 0; i < tamanho; i++) // O(N)
		if(v[i] == 10)
			ble = 2 * ble;
	
	int bli = 0;
	for(int i = 0; i < tamanho; i++) // O(N)
		if(v[i] == 5)
			bli += 5;
	
	return bla + ble + bli;
}

/*
	P1 & P2
		[O(N) * O(N)] + O(N) + O(N) = O(N^2) + 2 * O(N)
	
	P3
		O(N^2) + O(N)
		O(N^2)
	
	Complexidade Quadratica -> O(N^2)
*/
```

```cpp
bool exemple4(vector<int> v, vector<int> w) {
	int tamanho1 = v.size();
	int tamanho2 = w.size();
	
	for(int i = 0; i < tamanho1; i++) // O(N)
		for(int j = 0; j < tamanho2; j++) // O(M)
			if(v[i] == v[j])
				return true;
	
	return false;
}

/*
	Complexidade -> O(N) * O(M)
*/
```

```cpp
/*
	Ambos os exemplos fazem a mesma coisa!
*/

bool example5(vector<int> idades) {
	int tamanho = idades.size(); // O(1)
	int menor_idade = 200;
	
	for(int i = 0; i < tamanho; i++) // O(N)
		if(idades[i] < menor_idade)
			menor_idade = idades[i];
	
	int cont = 0;
	for(int i = 0; i < tamanho; i++) // O(N)
		if(v[i] == menor_idade)
			cont++;
	
	return cont > 1;
}

/*
	P1 & P2
		O(N) + O(N) = 2 * O(N)
	
	P3
		Complexidade Linear = O(N)
*/

bool example6(vector<int> idades) {
	sort(idades.begin(), idades.end()); // O(N * logN)
	return idades[0] == idades[1];
}

/*
	Complexidade NlogN = O(N * logN)
*/
```

```cpp
bool example7(set<int> s, vector<int> v) {
	int tamanho = v.size();
	for(int i = 0; i < tamanho; i++) // O(N)
		if(s.count(v[i])) // O(logN)
			return true;
	
	return false;
}

/*
	O(N) * O(logN) = O(N * logN)
	
	Complexidade NlogN = O(N * logN)
*/
```

</script>
</zero-md>
<!-- ARTICLE END -->

<footer>
    <a href="../../papers.html">
        <p id="footer-text">0xDant &copy; 2023</p>
    </a>
</footer>

</body>
</html>
